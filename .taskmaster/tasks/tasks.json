{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "기반 시스템 구축 및 사용자 인증 구현",
        "description": "FastAPI 백엔드, React 프론트엔드, PostgreSQL 및 Qdrant 데이터베이스를 포함한 프로젝트의 기본 인프라를 설정합니다. JWT 기반의 안전한 사용자 회원가입 및 로그인 시스템을 구현합니다.",
        "details": "백엔드: FastAPI, PostgreSQL, Qdrant. 프론트엔드: React, TypeScript, MUI. 인증: JWT 토큰. 데이터베이스 스키마(users, notes, chat_sessions, chat_messages)를 설계하고 생성해야 합니다.",
        "testStrategy": "사용자 회원가입, 로그인, 로그아웃 API 엔드포인트에 대한 단위/통합 테스트를 수행합니다. JWT 토큰이 올바르게 생성되고 검증되는지 확인합니다.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement User Database Schema",
            "description": "Create the necessary database table(s) to store user information, including credentials and profile data.",
            "dependencies": [],
            "details": "Define a 'users' table with columns: id (PK, auto-increment), email (unique, string), password_hash (string), created_at (timestamp), and updated_at (timestamp). Use a database migration tool to create and apply the schema.",
            "status": "pending",
            "testStrategy": "Verify the table and its columns are created correctly in the database. Manually test constraints like 'unique' by attempting to insert duplicate email addresses."
          },
          {
            "id": 2,
            "title": "Develop API Endpoint for User Registration",
            "description": "Create a public API endpoint (e.g., POST /api/auth/register) that allows new users to create an account.",
            "dependencies": [
              1
            ],
            "details": "The endpoint should accept email and password. It must validate input (e.g., password strength, valid email format), hash the password using a strong algorithm like bcrypt, and store the new user in the 'users' table. On success, return a 201 status code and the created user object (excluding the password hash).",
            "status": "pending",
            "testStrategy": "Write integration tests to cover: successful registration, registration with a duplicate email (should fail), registration with an invalid email format, and registration with a weak password. Verify that the password stored in the database is correctly hashed."
          },
          {
            "id": 3,
            "title": "Develop API Endpoint for User Login",
            "description": "Create a public API endpoint (e.g., POST /api/auth/login) for users to authenticate and receive an access token.",
            "dependencies": [
              1
            ],
            "details": "The endpoint should accept email and password. It will find the user by email, compare the provided password with the stored hash. If credentials are valid, generate and return a JSON Web Token (JWT) containing the user ID and an expiration date.",
            "status": "pending",
            "testStrategy": "Write integration tests for: successful login with correct credentials (should return a valid JWT), login with incorrect password (should return 401 Unauthorized), and login with a non-existent email (should return 401 Unauthorized)."
          },
          {
            "id": 4,
            "title": "Implement Authentication Middleware for Protected Routes",
            "description": "Create server-side middleware to verify the JWT on incoming requests to secure specific endpoints.",
            "dependencies": [
              3
            ],
            "details": "The middleware should extract the JWT from the 'Authorization: Bearer <token>' header. It must verify the token's signature and check for expiration. If the token is valid, decode the user ID from its payload and attach the user object to the request for use in subsequent handlers. If invalid, return a 401 or 403 error.",
            "status": "pending",
            "testStrategy": "Create a protected test endpoint. Write tests to access it with a valid token (should succeed), an expired token (should fail), a malformed token (should fail), and no token (should fail)."
          },
          {
            "id": 5,
            "title": "Create Frontend Registration and Login UI Forms",
            "description": "Build the user interface components for the registration and login pages, including form handling and API integration.",
            "dependencies": [
              2,
              3
            ],
            "details": "Create two separate UI views/components for registration and login. Implement form state management, client-side validation, and error handling. On form submission, call the respective API endpoints. On successful login, securely store the received JWT (e.g., in an HttpOnly cookie or local storage) and redirect the user.",
            "status": "pending",
            "testStrategy": "Use component tests to verify form rendering and validation logic. Use end-to-end tests (e.g., Cypress, Playwright) to simulate user input, form submission, and verify UI behavior for both successful and failed API responses."
          },
          {
            "id": 6,
            "title": "Implement Frontend Protected Routing",
            "description": "Create a protected route (e.g., /dashboard) that is only accessible to authenticated users.",
            "dependencies": [
              4,
              5
            ],
            "details": "Implement a route guard or wrapper component in the frontend application. This guard will check for the presence and validity of the authentication token before rendering the protected component. If no valid token exists, the user should be redirected to the login page. The dashboard page should fetch user-specific data from a new protected backend endpoint.",
            "status": "pending",
            "testStrategy": "End-to-end tests: 1) Attempt to access /dashboard directly while logged out (should redirect to /login). 2) Log in and verify that navigation to /dashboard is successful. 3) Implement a logout button that clears the token and redirects to login, then verify /dashboard is no longer accessible."
          }
        ]
      },
      {
        "id": 2,
        "title": "핵심 노트 관리(CRUD) 기능 개발",
        "description": "사용자가 텍스트 노트를 생성, 조회, 수정, 삭제할 수 있는 핵심 기능을 구현합니다. 이 기능은 사용자별로 데이터가 격리되어야 합니다.",
        "details": "FastAPI를 사용하여 노트의 CRUD를 처리하는 RESTful API 엔드포인트를 생성합니다. 각 노트는 user_id와 연결되어 PostgreSQL에 메타데이터가 저장되어야 합니다.",
        "testStrategy": "노트 생성, 특정 노트 조회, 사용자별 노트 목록 조회, 노트 업데이트, 노트 삭제 API에 대한 테스트 케이스를 작성하고 실행합니다. 사용자 데이터 격리를 확인합니다.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement User Database Schema",
            "description": "Create the necessary database table(s) to store user information, including credentials and profile data. This is the foundational step for all user-related features.",
            "dependencies": [],
            "details": "Define a 'users' table with columns for id, username (unique), email (unique), password_hash, created_at, and updated_at. Use a database migration tool to apply the schema. Create a corresponding User model in the application's ORM.",
            "status": "pending",
            "testStrategy": "Write unit tests for the User model to verify constraints and properties. Run migrations and manually inspect the database schema to confirm it's created correctly."
          },
          {
            "id": 2,
            "title": "Develop User Registration API Endpoint",
            "description": "Create a public API endpoint (e.g., POST /api/users/register) that allows new users to create an account.",
            "dependencies": [
              1
            ],
            "details": "The endpoint should accept username, email, and password. It must validate input, check for existing username/email, and enforce password complexity rules. Hash the password using bcrypt before saving the new user record. Return a 201 Created status on success.",
            "status": "pending",
            "testStrategy": "Write integration tests to cover success cases (new user created), failure cases (duplicate username/email, invalid input, weak password), and edge cases. Verify correct HTTP status codes and that passwords are not returned in the response."
          },
          {
            "id": 3,
            "title": "Implement User Login and JWT Issuance",
            "description": "Create an API endpoint (e.g., POST /api/auth/login) for users to authenticate and receive a JSON Web Token (JWT) for session management.",
            "dependencies": [
              1
            ],
            "details": "The endpoint will accept a username/email and a password. It will verify the credentials against the stored password hash. Upon successful authentication, generate a signed JWT containing the user ID, roles, and an expiration claim. Return the JWT in the response body.",
            "status": "pending",
            "testStrategy": "Write integration tests for the login endpoint. Test with valid credentials (should return a JWT), invalid credentials (should return a 401 Unauthorized error), and malformed requests. Unit test the JWT generation logic separately."
          },
          {
            "id": 4,
            "title": "Create Authentication Middleware for Protected Routes",
            "description": "Implement middleware to protect specific API routes, requiring a valid JWT for access.",
            "dependencies": [
              3
            ],
            "details": "The middleware should extract the JWT from the 'Authorization: Bearer <token>' header. It must verify the token's signature and expiration. If valid, decode the payload, identify the user, and attach the user information to the request context. If invalid, return a 401 Unauthorized error.",
            "status": "pending",
            "testStrategy": "Create a sample protected endpoint. Write integration tests that attempt to access it with a valid token, an invalid token, an expired token, and no token. Verify that access is granted or denied correctly with the appropriate HTTP status codes."
          }
        ]
      },
      {
        "id": 3,
        "title": "벡터 임베딩 및 저장 시스템 구축",
        "description": "노트가 생성되거나 수정될 때, 해당 내용을 한국어 특화 임베딩 모델(KURE-v1)을 사용하여 벡터로 변환하고 Qdrant 벡터 데이터베이스에 저장하는 시스템을 구축합니다.",
        "details": "Sentence Transformers 라이브러리와 KURE-v1 모델을 사용하여 임베딩 서비스를 구현합니다. 노트 생성/수정 시 비동기적으로 벡터 변환 및 Qdrant 저장이 이루어져야 합니다. 긴 텍스트는 청크 단위로 분할하여 처리합니다.",
        "testStrategy": "주어진 텍스트가 올바른 차원의 벡터로 변환되는지 확인합니다. 생성된 벡터가 노트 ID와 함께 Qdrant에 성공적으로 저장되고 검색되는지 검증합니다.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Set Up User Database Schema",
            "description": "Create the necessary database tables and columns to store user information, including credentials and profile data.",
            "dependencies": [],
            "details": "The `users` table should include columns for `id` (primary key), `username` (unique), `email` (unique), `password_hash`, `created_at`, and `updated_at`. Use a database migration tool like Alembic or Flyway to manage schema changes.",
            "status": "pending",
            "testStrategy": "Write a unit test to verify that the migration script correctly creates the table with all specified columns and constraints. Manually inspect the database schema after running the migration to confirm."
          },
          {
            "id": 2,
            "title": "Develop User Registration API Endpoint",
            "description": "Create a public API endpoint (e.g., `POST /api/users/register`) that allows new users to create an account.",
            "dependencies": [
              1
            ],
            "details": "The endpoint must validate input (e.g., password strength, valid email format), check for existing username/email, hash the password using bcrypt, and save the new user record to the database. Return a success message or user object upon successful registration.",
            "status": "pending",
            "testStrategy": "Write integration tests to cover successful registration, registration with a duplicate username/email, and registration with invalid input. Verify that the password stored in the database is correctly hashed."
          },
          {
            "id": 3,
            "title": "Implement User Login and JWT Generation",
            "description": "Create an API endpoint (e.g., `POST /api/auth/login`) for users to log in and receive a JSON Web Token (JWT).",
            "dependencies": [
              1
            ],
            "details": "The endpoint will accept user credentials, retrieve the user from the database, compare the provided password with the stored hash, and if they match, generate a signed JWT. The JWT payload should contain the user ID and an expiration claim.",
            "status": "pending",
            "testStrategy": "Write integration tests for successful login with correct credentials, failed login with incorrect credentials, and failed login for a non-existent user. Verify that a valid JWT is returned on success."
          },
          {
            "id": 4,
            "title": "Create Protected Routes and Authentication Middleware",
            "description": "Implement middleware to protect certain API endpoints, ensuring they can only be accessed by authenticated users with a valid JWT.",
            "dependencies": [
              3
            ],
            "details": "The middleware should inspect the `Authorization` header for a Bearer token. It must validate the JWT's signature and expiration. If valid, extract the user information from the token and attach it to the request object. If invalid, return a 401 Unauthorized error.",
            "status": "pending",
            "testStrategy": "Test a protected endpoint by making requests with a valid token (should succeed), with an invalid or expired token (should fail with 401), and with no token at all (should fail with 401)."
          }
        ]
      },
      {
        "id": 4,
        "title": "의미 기반 검색 기능 구현",
        "description": "사용자 쿼리를 벡터로 변환하여 Qdrant에서 의미적으로 유사한 노트를 검색하는 API를 구현합니다. 전통적인 키워드 검색의 한계를 극복하는 것을 목표로 합니다.",
        "details": "검색 쿼리를 받는 API 엔드포인트를 만듭니다. 쿼리는 KURE-v1 모델로 임베딩된 후 Qdrant의 유사도 검색 API를 호출하는 데 사용됩니다. 검색 결과는 관련성 순으로 정렬되어야 합니다.",
        "testStrategy": "다양한 의미적 쿼리(예: 동의어, 문맥적 질문)에 대해 관련성 높은 노트가 상위에 랭크되는지 테스트합니다. 검색 응답 시간이 2초 이내인지 성능을 측정합니다.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement Database Schema for Products",
            "description": "Create the database table structure required to store product information, including name, description, price, and stock quantity.",
            "dependencies": [],
            "details": "Define a 'products' table with the following columns: 'id' (INT, PRIMARY KEY, AUTO_INCREMENT), 'name' (VARCHAR(255), NOT NULL), 'description' (TEXT), 'price' (DECIMAL(10, 2), NOT NULL), 'stock_quantity' (INT, NOT NULL, DEFAULT 0), 'created_at' (TIMESTAMP, DEFAULT CURRENT_TIMESTAMP). Use a migration script to apply this schema to the development database.",
            "status": "pending",
            "testStrategy": "Run the migration and manually inspect the database schema using a database client to confirm the 'products' table and all specified columns, types, and constraints have been created correctly."
          },
          {
            "id": 2,
            "title": "Develop API Endpoint to Create a New Product",
            "description": "Implement a RESTful API endpoint (e.g., POST /api/products) that allows for the creation of a new product record in the database.",
            "dependencies": [
              1
            ],
            "details": "The endpoint should accept a JSON payload containing the product's name, description, price, and stock quantity. It must validate the input data (e.g., price must be a positive number, name cannot be empty). Upon successful validation, it should insert a new record into the 'products' table and return the newly created product object with its ID and a 201 Created status code.",
            "status": "pending",
            "testStrategy": "Write integration tests that send valid payloads to the endpoint and assert that a 201 status is returned and the product data is correctly saved in the database. Also, test with invalid data (e.g., missing name, negative price) and assert that a 400 Bad Request status and appropriate error messages are returned."
          },
          {
            "id": 3,
            "title": "Develop API Endpoint to Retrieve a Product by ID",
            "description": "Implement a RESTful API endpoint (e.g., GET /api/products/{id}) to fetch the details of a single product using its unique identifier.",
            "dependencies": [
              1,
              2
            ],
            "details": "The endpoint should take a product ID as a URL parameter. It will query the 'products' table for a record matching that ID. If found, it should return the full product object as JSON with a 200 OK status. If no product with the given ID exists, it should return a 404 Not Found status.",
            "status": "pending",
            "testStrategy": "First, create a product using the POST endpoint or by seeding the database. Then, write an integration test that calls the GET endpoint with the known product ID and verifies the returned data is correct. Write another test for a non-existent ID and assert that a 404 status code is returned."
          }
        ]
      },
      {
        "id": 5,
        "title": "기본 AI 대화형 어시스턴트 구현",
        "description": "사용자의 질문에 대해 저장된 노트를 기반으로 답변을 생성하는 AI 채팅 기능을 구현합니다. Google Gemini API와 RAG(Retrieval-Augmented Generation) 패턴을 사용합니다.",
        "details": "사용자 질문을 받으면, 의미 기반 검색(Task 4)을 통해 관련 노트를 컨텍스트로 찾습니다. 이 컨텍스트와 질문을 프롬프트로 구성하여 Gemini API에 전달하고, 생성된 답변을 사용자에게 반환합니다.",
        "testStrategy": "저장된 노트 내용과 관련된 질문을 했을 때, AI가 해당 내용을 기반으로 정확하고 일관된 답변을 생성하는지 확인합니다. API 비용 및 토큰 사용량을 모니터링합니다.",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Set Up User Database Schema",
            "description": "Create the necessary database tables to store user information, including credentials and profile data.",
            "dependencies": [],
            "details": "The 'users' table should include columns for 'id' (primary key), 'email' (unique), 'password_hash' (string), 'created_at', and 'updated_at'. Use a database migration script to create and version the schema.",
            "status": "pending",
            "testStrategy": "Verify the table and columns are created correctly in the database. Write a unit test for the migration script to ensure it can be applied and rolled back without errors."
          },
          {
            "id": 2,
            "title": "Develop User Registration API Endpoint",
            "description": "Create a public API endpoint (e.g., POST /api/register) that allows new users to sign up.",
            "dependencies": [
              1
            ],
            "details": "The endpoint must accept email and password. It should validate the input (e.g., password strength, valid email format), check if the email is already in use, hash the password using a strong algorithm like bcrypt, and save the new user record to the database.",
            "status": "pending",
            "testStrategy": "Write integration tests to cover successful registration, registration with a duplicate email, and registration with invalid input (e.g., weak password, bad email format). Verify that the password stored in the database is properly hashed."
          },
          {
            "id": 3,
            "title": "Implement User Login API Endpoint and Token Generation",
            "description": "Create an API endpoint (e.g., POST /api/login) for users to authenticate and receive a session token.",
            "dependencies": [
              1
            ],
            "details": "The endpoint should accept an email and password. It will find the user by email and verify the provided password against the stored hash. Upon success, generate a signed JSON Web Token (JWT) containing the user ID and an expiration date. Return the JWT to the client.",
            "status": "pending",
            "testStrategy": "Write integration tests for successful login with correct credentials, failed login with an incorrect password, and failed login for a non-existent user. Verify the structure and signature of the returned JWT."
          },
          {
            "id": 4,
            "title": "Create Authentication Middleware for Protected Routes",
            "description": "Implement middleware to protect specific API endpoints, requiring a valid JWT for access.",
            "dependencies": [
              3
            ],
            "details": "The middleware should extract the JWT from the 'Authorization' header. It must validate the token's signature and check for expiration. If valid, it decodes the token, retrieves the user from the database, and attaches the user object to the request. If invalid, it returns a 401 Unauthorized error.",
            "status": "pending",
            "testStrategy": "Create a test endpoint protected by the middleware. Write tests to ensure access is granted with a valid token and denied with no token, an invalid token, or an expired token. Verify user information is correctly attached to the request on success."
          }
        ]
      },
      {
        "id": 6,
        "title": "다양한 콘텐츠 소스 처리 기능 개발",
        "description": "사용자가 텍스트를 직접 입력하는 것 외에 PDF, DOCX 파일 및 웹 URL로부터 콘텐츠를 가져와 노트로 저장하는 기능을 개발합니다.",
        "details": "파일 업로드(PDF, DOCX)를 위한 텍스트 추출 라이브러리를 통합합니다. URL을 입력받아 해당 웹페이지의 본문 텍스트를 스크레이핑하는 기능을 구현합니다. 추출된 텍스트는 노트 생성 프로세스를 통해 처리됩니다.",
        "testStrategy": "다양한 형식의 PDF/DOCX 파일과 여러 구조의 웹페이지를 입력하여 텍스트가 정확하게 추출되고 노트로 저장되는지 테스트합니다. 10MB 이하 파일 업로드를 지원하는지 확인합니다.",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Create User Database Schema",
            "description": "Define and create the necessary database tables to store user information, including credentials and profile data.",
            "dependencies": [],
            "details": "Create a migration script for a 'users' table. The table should include columns for 'id' (primary key, auto-increment), 'email' (unique, indexed), 'hashed_password' (string), 'created_at', and 'updated_at'.",
            "status": "pending",
            "testStrategy": "Run the migration and verify the table schema is created correctly in a test database. Write a test to ensure the migration can be rolled back successfully."
          },
          {
            "id": 2,
            "title": "Develop User Registration API Endpoint",
            "description": "Create a public API endpoint (e.g., POST /api/register) that allows new users to sign up by providing their email and password.",
            "dependencies": [
              1
            ],
            "details": "The endpoint must validate input: check for a valid email format and enforce password complexity rules. Hash the password using a strong algorithm like bcrypt before storing it in the 'users' table. Return a 201 status on success.",
            "status": "pending",
            "testStrategy": "Write integration tests for: successful registration, registration with a duplicate email, registration with an invalid email format, and registration with a weak password. Ensure password hashes are stored, not plain text."
          },
          {
            "id": 3,
            "title": "Implement User Login and JWT Generation",
            "description": "Create an API endpoint (e.g., POST /api/login) to authenticate users and issue a JSON Web Token (JWT) upon successful login.",
            "dependencies": [
              1
            ],
            "details": "The endpoint will receive an email and password. It should find the user by email, verify the provided password against the stored hash, and if valid, generate a signed JWT. The JWT payload should include the user ID and have a reasonable expiration time.",
            "status": "pending",
            "testStrategy": "Write integration tests for successful login with correct credentials, failed login with incorrect credentials, and login attempts for a non-existent user. Unit test the JWT generation and signature verification logic separately."
          }
        ]
      },
      {
        "id": 7,
        "title": "노트 카테고리 관리 및 필터링 기능 구현",
        "description": "사용자가 노트를 주제별로 분류하고 관리할 수 있도록 카테고리 생성, 할당, 필터링 기능을 구현합니다.",
        "details": "사용자가 카테고리를 생성하고 노트에 할당할 수 있는 UI와 API를 개발합니다. 노트 목록 조회 시 특정 카테고리별로 필터링하여 볼 수 있는 기능을 추가합니다.",
        "testStrategy": "카테고리 생성/수정/삭제가 정상적으로 동작하는지 확인합니다. 노트를 특정 카테고리에 할당하고, 해당 카테고리로 필터링했을 때 올바른 노트 목록이 반환되는지 검증합니다.",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Create User Database Schema",
            "description": "Define and create the necessary database tables to store user information, including credentials and profile data.",
            "dependencies": [],
            "details": "Create a 'users' table with columns for 'id' (primary key), 'email' (unique), 'password_hash' (string), 'created_at', and 'updated_at'. Use a database migration tool to manage the schema.",
            "status": "pending",
            "testStrategy": "Verify table and column creation directly in the database. Write a migration test to ensure it can be applied and rolled back successfully."
          },
          {
            "id": 2,
            "title": "Develop Backend API for User Authentication",
            "description": "Implement the server-side logic and API endpoints for user registration and login.",
            "dependencies": [
              1
            ],
            "details": "Create two endpoints: POST /api/register and POST /api/login. The registration endpoint should validate input, hash the password using bcrypt, and store the new user. The login endpoint should verify credentials and return a JWT upon success.",
            "status": "pending",
            "testStrategy": "Write unit tests for the password hashing logic. Write integration tests for the /register and /login endpoints, mocking the database interaction and asserting correct responses and status codes."
          },
          {
            "id": 3,
            "title": "Build Frontend UI for Registration and Login Forms",
            "description": "Create the user interface components for the registration and login pages.",
            "dependencies": [
              2
            ],
            "details": "Using a frontend framework like React or Vue, create 'RegistrationForm' and 'LoginForm' components. Implement client-side validation and API calls to the endpoints created in subtask 2. Handle API responses to show success/error messages and manage user session state with the received JWT.",
            "status": "pending",
            "testStrategy": "Use component tests to verify form rendering and validation logic. Conduct end-to-end tests using Cypress or Playwright to simulate a full user registration and login flow."
          }
        ]
      },
      {
        "id": 8,
        "title": "AI 채팅 기능 고도화",
        "description": "AI 어시스턴트의 사용자 경험을 향상시키기 위해 다중 채팅 세션 관리, 대화 기록 보존, 실시간 스트리밍 응답 기능을 구현합니다.",
        "details": "사용자별로 여러 채팅 세션을 생성하고 관리할 수 있는 DB 모델과 API를 구현합니다. Gemini API의 스트리밍 응답을 처리하여 UI에 실시간으로 표시합니다. 이전 대화 내용을 컨텍스트로 활용하여 멀티턴 대화가 가능하도록 개선합니다.",
        "testStrategy": "여러 채팅 탭/세션을 열고 각기 다른 대화를 진행할 수 있는지 테스트합니다. AI의 답변이 타이핑되듯 실시간으로 표시되는지 확인합니다. 채팅방을 나갔다 다시 들어와도 이전 대화 기록이 유지되는지 검증합니다.",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Create User Authentication Database Schema",
            "description": "Define and create the necessary database tables to store user credentials and session information, including tables for users and roles.",
            "dependencies": [],
            "details": "Create a 'users' table with columns for id, username, email, password_hash, created_at, and updated_at. Use a secure hashing algorithm like bcrypt for passwords. Implement migrations to manage schema changes.",
            "status": "pending",
            "testStrategy": "Run migration scripts against a test database to verify schema creation. Write unit tests for data models to check constraints like unique email addresses."
          },
          {
            "id": 2,
            "title": "Develop API Endpoints for Registration and Login",
            "description": "Create the backend API endpoints for user registration (/api/auth/register) and user login (/api/auth/login).",
            "dependencies": [
              1
            ],
            "details": "The registration endpoint will validate input, hash the password, and save the new user. The login endpoint will verify credentials and generate a JWT or session token upon successful authentication.",
            "status": "pending",
            "testStrategy": "Write integration tests for both endpoints. Test registration with valid data, duplicate data, and invalid input. Test login with correct credentials, incorrect credentials, and for non-existent users."
          },
          {
            "id": 3,
            "title": "Implement Authentication Middleware for Protected Routes",
            "description": "Create middleware to verify the authentication token from incoming requests, protecting specific API routes from unauthorized access.",
            "dependencies": [
              2
            ],
            "details": "The middleware should extract the token from the 'Authorization' header, validate its signature and expiration. If valid, attach user data to the request object. If invalid, return a 401 Unauthorized status.",
            "status": "pending",
            "testStrategy": "Unit test the middleware logic. Write integration tests for a protected endpoint to ensure it allows access with a valid token and denies access with an invalid, expired, or missing token."
          },
          {
            "id": 4,
            "title": "Create Frontend UI for Login and Registration Forms",
            "description": "Build the user interface components for the login and registration pages using a frontend framework like React or Vue.",
            "dependencies": [
              2
            ],
            "details": "Develop two forms with client-side validation for email format and password strength. On submission, call the respective API endpoints and handle success or error responses by redirecting the user or displaying an error message.",
            "status": "pending",
            "testStrategy": "Use component tests for form validation and state management. Conduct end-to-end tests to simulate a full user registration and login flow. Manually test UI/UX across major browsers."
          }
        ]
      },
      {
        "id": 9,
        "title": "프론트엔드 UI/UX 구현 및 개선",
        "description": "React와 Material-UI를 사용하여 직관적이고 반응형인 사용자 인터페이스를 구현합니다. 노트 관리, 콘텐츠 업로드, AI 채팅 등 모든 기능에 대한 UI를 개발합니다.",
        "details": "회원가입/로그인, 노트 목록/상세, 파일 업로드, AI 채팅 화면을 구현합니다. 로딩 상태, 진행률 표시 등 실시간 피드백을 제공합니다. 모바일, 태블릿, 데스크탑 등 다양한 화면 크기에 대응하는 반응형 디자인을 적용합니다.",
        "testStrategy": "주요 사용자 플로우(회원가입 → 노트 생성 → 검색 → AI 채팅)를 따라 UI를 테스트합니다. 다양한 디바이스와 브라우저에서 레이아웃이 깨지지 않는지 확인합니다.",
        "priority": "high",
        "dependencies": [
          5,
          6,
          7,
          8
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement User Database Schema",
            "description": "Create the database table(s) to store user information, including credentials and profile data.",
            "dependencies": [],
            "details": "Define a 'users' table with columns for id (primary key), email (unique), hashed_password, created_at, and updated_at. Use a database migration tool (e.g., Alembic, Flyway, Knex.js migrations) to create and version the schema.",
            "status": "pending",
            "testStrategy": "Verify the migration runs successfully up and down. Manually inspect the database schema to confirm all columns, types, and constraints are correctly defined."
          },
          {
            "id": 2,
            "title": "Implement Secure Password Hashing and Verification Logic",
            "description": "Create utility functions for securely hashing passwords upon registration and verifying them during login.",
            "dependencies": [],
            "details": "Use a strong, adaptive hashing algorithm like Argon2 or bcrypt. Do not use outdated algorithms like MD5 or SHA1. Create two functions: `hashPassword(plainTextPassword)` and `verifyPassword(plainTextPassword, hashedPassword)`. The salt should be generated automatically and stored as part of the hash string.",
            "status": "pending",
            "testStrategy": "Unit test the hashing and verification functions. Ensure `verifyPassword` returns true for the correct password and false for an incorrect one. Ensure the same password results in a different hash each time due to salting."
          },
          {
            "id": 3,
            "title": "Create User Registration API Endpoint",
            "description": "Develop a public API endpoint (e.g., POST /api/auth/register) for new users to create an account.",
            "dependencies": [
              1,
              2
            ],
            "details": "The endpoint should accept user data (e.g., email, password) in the request body. It must validate the input (e.g., check for existing email, password complexity). On success, it should use the password hashing utility to hash the password and store the new user in the database.",
            "status": "pending",
            "testStrategy": "Integration tests: send valid registration data and assert a 201 Created response and user creation in the DB. Test with invalid data (duplicate email, weak password) and assert appropriate 4xx error responses."
          },
          {
            "id": 4,
            "title": "Create User Login API Endpoint and Token Generation",
            "description": "Develop an endpoint (e.g., POST /api/auth/login) for users to authenticate and receive a JWT.",
            "dependencies": [
              1,
              2
            ],
            "details": "The endpoint will find the user by email, use the `verifyPassword` utility to check credentials, and upon success, generate a signed JSON Web Token (JWT). The JWT payload should include the user ID and an expiration claim. The JWT secret key must be stored securely as an environment variable.",
            "status": "pending",
            "testStrategy": "Integration tests: test with valid credentials and assert a 200 OK response with a valid JWT. Test with invalid credentials (wrong password, non-existent user) and assert a 401 Unauthorized error."
          },
          {
            "id": 5,
            "title": "Implement Authentication Middleware for Protected Routes",
            "description": "Create middleware to verify the JWT on incoming requests to protected API endpoints.",
            "dependencies": [
              4
            ],
            "details": "The middleware will extract the token from the 'Authorization: Bearer <token>' header. It will then validate the token's signature and expiration. If valid, it should attach the user's information (e.g., user ID from the token payload) to the request object. If invalid, it must return a 401 Unauthorized response.",
            "status": "pending",
            "testStrategy": "Create a dummy protected endpoint. Integration test it by sending a request with a valid token (expect 200 OK), no token (expect 401), and an invalid/expired token (expect 401)."
          },
          {
            "id": 6,
            "title": "Implement User Profile Endpoint",
            "description": "Create a protected endpoint (e.g., GET /api/users/me) that returns the authenticated user's profile information.",
            "dependencies": [
              1,
              5
            ],
            "details": "This endpoint must be protected by the authentication middleware created in the previous task. It will use the user ID from the request object (attached by the middleware) to fetch the user's non-sensitive data (e.g., id, email, created_at) from the database and return it.",
            "status": "pending",
            "testStrategy": "Integration test the endpoint with a valid token and assert the correct user data is returned. Test access without a token and assert a 401 error is returned."
          },
          {
            "id": 7,
            "title": "Implement Logout Functionality with Token Denylist",
            "description": "Develop an endpoint (e.g., POST /api/auth/logout) to invalidate the user's current JWT.",
            "dependencies": [
              5
            ],
            "details": "Implement a token denylist using a fast-access cache like Redis. The logout endpoint will add the JWT's unique identifier (JTI claim) to this list with a TTL matching the token's remaining validity. The authentication middleware must be updated to check this denylist before validating the token.",
            "status": "pending",
            "testStrategy": "Integration test: 1. Login to get a token. 2. Call the logout endpoint. 3. Attempt to use the same token to access a protected route and assert a 401 Unauthorized response."
          }
        ]
      },
      {
        "id": 10,
        "title": "성능 최적화 및 보안 강화",
        "description": "프로덕션 배포를 위해 시스템 전반의 성능을 최적화하고 보안 요구사항을 충족시킵니다. 안정적인 서비스 운영을 목표로 합니다.",
        "details": "API 응답 시간, DB 쿼리, 임베딩 속도를 최적화합니다. 모든 통신에 HTTPS를 적용하고, API 요청 제한(Rate Limiting)을 구현합니다. 에러 처리 로직을 강화하고 사용자에게 명확한 피드백을 제공합니다.",
        "testStrategy": "부하 테스트를 통해 동시 사용자 100명 이상을 지원하는지 확인합니다. 보안 취약점 스캔을 수행합니다. 주요 기능의 응답 시간이 성능 요구사항(검색 2초, 채팅 시작 1초)을 만족하는지 측정합니다.",
        "priority": "low",
        "dependencies": [
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Create User Database Schema",
            "description": "Define and implement the database schema for storing user information, including credentials and profile data, using a migration script.",
            "dependencies": [],
            "details": "Create a `users` table with columns: `id` (UUID, primary key), `email` (VARCHAR, unique, not null), `password_hash` (VARCHAR, not null), `created_at` (TIMESTAMPZ), and `updated_at` (TIMESTAMPZ). Use a database migration tool like Alembic or Flyway to generate and apply the schema changes.",
            "status": "pending",
            "testStrategy": "Run the migration and verify the table structure and constraints (e.g., UNIQUE on email) are correctly created in a test database. Write a test to ensure inserting a duplicate email fails at the database level."
          },
          {
            "id": 2,
            "title": "Develop User Registration API Endpoint",
            "description": "Create a public API endpoint (e.g., `POST /api/v1/register`) that allows new users to create an account.",
            "dependencies": [
              1
            ],
            "details": "The endpoint should accept an email and password. It must validate the input (e.g., valid email format, strong password policy), hash the password using a strong algorithm like bcrypt, and store the new user record in the database. On success, return a 201 Created status with the new user's ID and email.",
            "status": "pending",
            "testStrategy": "Write unit tests for the validation and password hashing logic. Write integration tests to cover successful registration, registration with a duplicate email (expect 409 Conflict), and registration with invalid input (expect 400 Bad Request)."
          },
          {
            "id": 3,
            "title": "Implement Login Endpoint and JWT Generation",
            "description": "Create an API endpoint (e.g., `POST /api/v1/login`) for users to authenticate and receive a JSON Web Token (JWT).",
            "dependencies": [
              1
            ],
            "details": "The endpoint will accept an email and password. It should find the user by email, securely compare the provided password with the stored hash. If credentials are valid, generate a signed JWT containing the user ID, an expiration claim (`exp`), and an issued-at claim (`iat`). The JWT secret should be loaded from environment variables.",
            "status": "pending",
            "testStrategy": "Write integration tests for successful login (expect a 200 OK and a JWT in the response), login with an incorrect password (expect 401 Unauthorized), and login for a non-existent user (expect 401 Unauthorized). Unit test the JWT generation to ensure it contains the correct claims."
          },
          {
            "id": 4,
            "title": "Create Authentication Middleware for Protected Routes",
            "description": "Implement middleware to verify the JWT on incoming requests to secure specific API routes.",
            "dependencies": [
              3
            ],
            "details": "The middleware should extract the JWT from the `Authorization: Bearer <token>` header. It must validate the token's signature and check for expiration. If valid, decode the payload and attach the user's ID to the request context for use in protected handlers. If the token is invalid, expired, or missing, the middleware must respond with a 401 Unauthorized error.",
            "status": "pending",
            "testStrategy": "Create a sample protected endpoint (e.g., `GET /api/v1/profile`). Write integration tests attempting to access it: 1) without any token, 2) with an invalid/malformed token, 3) with an expired token, and 4) with a valid token. Verify that access is denied in the first three cases and granted in the last."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-07-13T14:55:08.399Z",
      "updated": "2025-07-13T14:55:08.399Z",
      "description": "Tasks for master context"
    }
  }
}